{% extends "base.html" %}

{% block title %}Bear Trap Map - DOA Dashboard{% endblock %}

{% block content %}
<style>
    .bear-trap-container {
        display: flex;
        flex-direction: column;
        gap: 2rem;
        margin-top: 2rem;
        align-items: center;
        position: relative;
    }

    .map-section {
        position: relative;
        perspective: 2000px;
        perspective-origin: center center;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 0;
        pointer-events: none;
        width: 100%;
    }

    .members-section {
        background-color: var(--surface-color);
        border-radius: 8px;
        padding: 1.5rem;
        border: 1px solid var(--border-color);
        max-height: 50vh;
        overflow-y: auto;
        width: 80%;
        max-width: 80%;
        position: relative;
        z-index: 10;
        margin-top: 4rem;
    }

    .grid-container {
        display: grid;
        grid-template-columns: repeat(15, 30px);
        grid-template-rows: repeat(15, 30px);
        gap: 2px;
        background-color: var(--background-color);
        padding: 1rem;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        position: relative;
        transform: rotateX(30deg) rotateZ(45deg) scale(1);
        transform-style: preserve-3d;
        pointer-events: auto;
    }

    /* Bear trap background image on center zone */
    .grid-container::after {
        content: '';
        position: absolute;
        left: calc(1rem + 6 * 30px + 6 * 2px);
        top: calc(1rem + 6 * 30px + 6 * 2px);
        width: calc(3 * 30px + 2 * 2px);
        height: calc(3 * 30px + 2 * 2px);
        background-image: url('../static/images/bear-trap-active-icon.webp');
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        transform: rotate(-45deg);
        pointer-events: none;
        z-index: 1;
    }

    .grid-cell {
        background-color: var(--surface-color);
        border: 1px solid var(--border-color);
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .grid-cell::before {
        content: attr(data-coords);
        font-size: 0.5rem;
        color: var(--text-color);
        opacity: 0.45;
        font-weight: 600;
        transform: rotate(-45deg);
        text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        white-space: nowrap;
        z-index: 0;
    }

    .grid-cell.center-zone {
        background-color: transparent;
        border: none;
        position: relative;
        z-index: 2;
    }

    .grid-cell.center-zone:hover {
        background-color: rgba(255, 215, 0, 0.1);
        cursor: pointer;
        border: 1px solid rgba(255, 215, 0, 0.5);
    }

    .grid-cell.center-zone.clickable-center:hover {
        background-color: rgba(255, 215, 0, 0.2);
        box-shadow: inset 0 0 8px rgba(255, 215, 0, 0.6);
    }


    /* Single 3x3 background square for center zone */
    .grid-container::before {
        content: '';
        position: absolute;
        left: calc(1rem + 6 * 30px + 6 * 2px);
        top: calc(1rem + 6 * 30px + 6 * 2px);
        width: calc(3 * 30px + 2 * 2px);
        height: calc(3 * 30px + 2 * 2px);
        background-color: rgba(255, 215, 0, 0.3);
        border: 2px solid gold;
        box-sizing: border-box;
        z-index: 2;
        pointer-events: none;
    }

    .player-card {
        background-color: var(--primary-color);
        border-radius: 4px;
        padding: 0.25rem;
        cursor: grab;
        user-select: none;
        border: 2px solid var(--border-color);
        font-size: 0.65rem;
        transition: transform 0.2s;
        width: 62px;
        height: 62px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        box-sizing: border-box;
        flex-shrink: 0;
        transform: rotateX(30deg) rotateZ(45deg);
        transform-style: preserve-3d;
        position: relative;
        overflow: hidden;
    }

    .player-card::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-image: var(--avatar-url, url('../static/images/player-castle-icon.webp'));
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        z-index: 0;
        opacity: 0.9;
    }

    .player-card::before {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: rgba(0, 168, 255, 0.4);
        z-index: 1;
        border-radius: 4px;
    }

    .player-card-text-wrapper {
        position: relative;
        z-index: 2;
        transform: rotate(-45deg);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .player-card > div {
        position: relative;
        z-index: 2;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.9), 1px 1px 2px rgba(0, 0, 0, 0.8);
        font-weight: 500;
        white-space: nowrap;
    }

    .player-card.used {
        opacity: 0.3;
        cursor: not-allowed;
        pointer-events: none;
    }

    .player-card:hover {
        transform: rotateX(30deg) rotateZ(45deg) scale(1.05);
    }

    .player-card.dragging {
        opacity: 0.8;
        cursor: grabbing;
        transform: rotateX(30deg) rotateZ(45deg);
    }

    .obstruction-card {
        background-color: #666;
        border-radius: 4px;
        padding: 0;
        margin-bottom: 0.5rem;
        cursor: grab;
        user-select: none;
        border: 2px solid #444;
        font-size: 0.8rem;
        text-align: center;
        color: white;
        font-weight: bold;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        transform: rotateX(30deg) rotateZ(45deg);
        transform-style: preserve-3d;
    }

    .obstruction-card::before {
        content: attr(data-emoji);
        transform: rotate(-45deg);
        display: block;
    }

    .obstruction-card:hover {
        transform: rotateX(30deg) rotateZ(45deg) scale(1.05);
    }

    /* Directional buttons on grid cells */
    .grid-cell.direction-btn {
        background-color: rgba(255, 255, 255, 0.2);
        cursor: pointer;
        transition: background-color 0.2s;
        user-select: none;
        z-index: 50;
        border: 1px solid rgba(218, 165, 32, 0.6);
        box-sizing: border-box;
        position: relative;
    }

    /* Move UP button down by 1px (towards center) */
    .grid-cell.direction-btn[data-direction="up"] {
        top: 1px;
    }

    /* Move DOWN button up by 1px (towards center) */
    .grid-cell.direction-btn[data-direction="down"] {
        top: -1px;
    }

    /* Move LEFT button right by 1px (towards center) */
    .grid-cell.direction-btn[data-direction="left"] {
        left: 1px;
    }

    /* Move RIGHT button left by 1px (towards center) */
    .grid-cell.direction-btn[data-direction="right"] {
        left: -1px;
    }

    .grid-cell.direction-btn:hover {
        background-color: rgba(255, 255, 255, 0.4);
        transform: scale(1.1);
    }

    /* Maintain positioning on hover for each direction */
    .grid-cell.direction-btn[data-direction="up"]:hover {
        top: 1px;
    }

    .grid-cell.direction-btn[data-direction="down"]:hover {
        top: -1px;
    }

    .grid-cell.direction-btn[data-direction="left"]:hover {
        left: 1px;
    }

    .grid-cell.direction-btn[data-direction="right"]:hover {
        left: -1px;
    }

    .grid-cell.direction-btn:active {
        background-color: rgba(255, 255, 255, 0.3);
    }

    /* Arrow content for direction buttons */
    .grid-cell.direction-btn::after {
        content: attr(data-arrow);
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1rem;
        font-weight: bold;
        color: var(--header-color);
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        z-index: 51;
        pointer-events: none;
    }

    .placed-player {
        position: absolute;
        background-color: var(--primary-color);
        border-radius: 4px;
        padding: 0.25rem;
        font-size: 0.55rem;
        border: 2px solid var(--border-color);
        cursor: move;
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        word-wrap: break-word;
        box-sizing: border-box;
        overflow: hidden;
        transition: border-color 0.2s;
    }

    .placed-player.active {
        border: 2px solid #0066cc;
        border-radius: 0;
    }

    .placed-player::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-image: var(--avatar-url, url('../static/images/player-castle-icon.webp'));
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        z-index: 0;
        opacity: 0.9;
    }

    .placed-player::before {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: rgba(0, 168, 255, 0.4);
        z-index: 1;
        border-radius: 4px;
    }

    .placed-player-text-wrapper {
        position: relative;
        z-index: 2;
        transform: rotate(-45deg);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .placed-player > div {
        position: relative;
        z-index: 2;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.9), 1px 1px 2px rgba(0, 0, 0, 0.8);
        font-weight: 600;
        white-space: nowrap;
    }

    .placed-obstruction {
        position: absolute;
        background-color: #666;
        border-radius: 4px;
        border: 2px solid #444;
        cursor: move;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 0.7rem;
        box-sizing: border-box;
        transition: border-color 0.2s;
    }

    .placed-obstruction::before {
        content: attr(data-emoji);
        transform: rotate(-45deg);
        display: block;
    }

    .placed-obstruction.active {
        border: 2px solid #0066cc;
        border-radius: 0;
    }

    .alliance-select {
        margin-bottom: 1.5rem;
    }

    .sort-links {
        margin-bottom: 1.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.9rem;
    }

    .sort-link {
        color: var(--text-color);
        text-decoration: none;
        cursor: pointer;
        opacity: 0.6;
        transition: opacity 0.2s;
    }

    .sort-link:hover {
        opacity: 1;
        text-decoration: underline;
    }

    .sort-link.active {
        opacity: 1;
        font-weight: bold;
        color: var(--primary-color);
    }

    .alliance-select select {
        width: 100%;
        padding: 0.5rem;
        border-radius: 4px;
        border: 2px solid var(--border-color);
        background-color: var(--background-color);
        color: var(--text-color);
        font-size: 1rem;
    }

    .members-list {
        margin-top: 1rem;
    }

    #player-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        perspective: 2000px;
        perspective-origin: center center;
    }

    .members-list h3 {
        color: var(--header-color);
        margin-bottom: 1rem;
        font-size: 1.1rem;
    }

    /* Light mode adjustments */
    body.light-mode .members-section {
        background-color: #ffffff;
    }

    body.light-mode .grid-container {
        background-color: #f5f5f5;
    }

    body.light-mode .grid-cell {
        background-color: #ffffff;
    }

    body.light-mode .player-card::before {
        background-color: rgba(0, 168, 255, 0.5);
    }

    body.light-mode .placed-player::before {
        background-color: rgba(0, 168, 255, 0.5);
    }

    body.light-mode .grid-cell.center-zone::before {
        background-color: rgba(255, 215, 0, 0.4);
    }


    /* Responsive grid scaling for different screen sizes */
    @media (min-width: 1441px) {
        .grid-container {
            transform: rotateX(30deg) rotateZ(45deg) scale(1.5);
        }

        .members-section {
            margin-top: 12rem;
        }
    }

    @media (max-width: 1440px) and (min-width: 1025px) {
        .grid-container {
            transform: rotateX(30deg) rotateZ(45deg) scale(1.3);
        }

        .members-section {
            margin-top: 32rem;
        }
    }

    @media (max-width: 1024px) {
        .grid-container {
            transform: rotateX(30deg) rotateZ(45deg) scale(0.85);
        }
    }

    @media (max-width: 768px) {
        .grid-container {
            transform: rotateX(30deg) rotateZ(45deg) scale(0.70);
        }
    }

    @media (max-width: 425px) {
        .grid-container {
            transform: rotateX(30deg) rotateZ(45deg) scale(0.65);
        }
    }

    @media (max-width: 375px) {
        .grid-container {
            transform: rotateX(30deg) rotateZ(45deg) scale(0.55);
        }
    }

    @media (max-width: 320px) {
        .grid-container {
            transform: rotateX(30deg) rotateZ(45deg) scale(0.50);
        }
    }

    /* Responsive adjustments for smaller screens */
    @media (max-width: 1440px) {
        .members-section {
            margin: 0 1rem;
        }
    }

    /* Tablet/Mobile responsive - scale grid to fit */
    @media (max-width: 768px) {
        .bear-trap-container {
            flex-direction: column;
        }

        .map-section {
            width: 100%;
            overflow: visible;
            display: flex;
            justify-content: center;
        }

        .grid-container {
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
            gap: 2px;
            padding: 0.5rem;
        }

        /* Adjust center zone positioning */
        .grid-container::before {
            left: calc(0.5rem + 6 * 30px + 6 * 2px);
            top: calc(0.5rem + 6 * 30px + 6 * 2px);
            width: calc(3 * 30px + 2 * 2px);
            height: calc(3 * 30px + 2 * 2px);
        }

        .grid-container::after {
            left: calc(0.5rem + 6 * 30px + 6 * 2px);
            top: calc(0.5rem + 6 * 30px + 6 * 2px);
            width: calc(3 * 30px + 2 * 2px);
            height: calc(3 * 30px + 2 * 2px);
        }

        .members-section {
            max-height: 50vh;
            width: 85%;
            max-width: 85%;
            margin-top: 2rem;
        }
    }

    /* Small mobile - further scale down */
    @media (max-width: 645px) {
        .grid-container {
            grid-template-columns: repeat(15, 25px);
            grid-template-rows: repeat(15, 25px);
            gap: 1px;
            padding: 0.5rem;
        }

        /* Adjust center zone positioning for smaller grid */
        .grid-container::before {
            left: calc(0.5rem + 6 * 25px + 6 * 1px);
            top: calc(0.5rem + 6 * 25px + 6 * 1px);
            width: calc(3 * 25px + 2 * 1px);
            height: calc(3 * 25px + 2 * 1px);
        }

        .grid-container::after {
            left: calc(0.5rem + 6 * 25px + 6 * 1px);
            top: calc(0.5rem + 6 * 25px + 6 * 1px);
            width: calc(3 * 25px + 2 * 1px);
            height: calc(3 * 25px + 2 * 1px);
        }

        .placed-player {
            font-size: 0.45rem;
            /* Player cards need to be smaller on mobile */
            width: 51px !important; /* 2 cells (25px each) + 1 gap (1px) */
            height: 51px !important;
        }

        .placed-player > div {
            font-size: 0.45rem;
        }

        .placed-obstruction {
            /* Obstructions need to be smaller too */
            width: 25px !important;
            height: 25px !important;
            font-size: 0.6rem;
        }
    }
</style>

<h1>Bear Trap Map</h1>

<div class="bear-trap-container">
    <div class="map-section">
        <div class="grid-container" id="grid"></div>

    </div>

    <div class="members-section">
        <div class="alliance-select">
            <label for="alliance-dropdown"><strong>Select Alliance:</strong></label>
            <select id="alliance-dropdown">
                <option value="">-- Select Alliance --</option>
                {% for alliance in alliances %}
                <option value="{{ alliance.alliance_id }}">{{ alliance.name }}</option>
                {% endfor %}
            </select>
        </div>

        <div class="members-list" id="members-list">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h3 style="margin: 0;">Drag Items to Grid</h3>
                <div class="sort-links" style="margin-bottom: 0;">
                    <span><strong>Sort:</strong></span>
                    <a href="#" id="sort-tc-link" class="sort-link active">TC â†“</a>
                    <span>|</span>
                    <a href="#" id="sort-alpha-link" class="sort-link">A-Z</a>
                </div>
            </div>
            <div class="obstruction-card" draggable="true" data-type="obstruction" data-emoji="ðŸš§">
            </div>
            <div id="player-cards"></div>
        </div>
    </div>
</div>

<script>
    const usersByAlliance = JSON.parse('{{ users_by_alliance | tojson | safe }}');
    const grid = document.getElementById('grid');
    const allianceDropdown = document.getElementById('alliance-dropdown');
    const sortTcLink = document.getElementById('sort-tc-link');
    const sortAlphaLink = document.getElementById('sort-alpha-link');
    const playerCardsContainer = document.getElementById('player-cards');

    let draggedElement = null;
    let placedItems = [];
    let currentAllianceId = null;
    let usedPlayers = new Set(); // Track which players have been placed
    let currentSortType = 'tc_desc'; // Default sort: TC high to low
    let tcSortAscending = false; // Track TC sort direction
    let alphaSortAscending = true; // Track alpha sort direction
    let lastPlacedElement = null; // Track the last placed element for keyboard control
    
    // Base coordinate for the center 3x3 zone (bottom-right cell at grid position 8,8)
    let baseCoordinate = { x: 101, y: 101 };
    
    // Helper function to update all grid coordinates
    function updateGridCoordinates() {
        const cells = grid.querySelectorAll('.grid-cell');
        cells.forEach(cell => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            // Formula: baseCoord + (centerCellPos - cellPos)
            // Center cell is at (8, 8), so offset = 8 - pos
            // X and Y axes are flipped: X uses row, Y uses col
            const worldX = baseCoordinate.x + (8 - row);
            const worldY = baseCoordinate.y + (8 - col);
            cell.dataset.coords = `${worldX},${worldY}`;
        });
    }
    // Helper function to calculate coordinates for a placed player (2x2 square)
    // Coordinate is based on bottom-right cell of the 2x2 square
    function getPlacedPlayerCoords(row, col) {
        // Bottom-right cell is at (row+1, col+1)
        const bottomRightRow = row + 1;
        const bottomRightCol = col + 1;
        // Use same formula as grid cells: baseCoord + (8 - pos)
        const worldX = baseCoordinate.x + (8 - bottomRightRow);
        const worldY = baseCoordinate.y + (8 - bottomRightCol);
        return { x: worldX, y: worldY };
    }

    // Helper function to update all placed player coordinates
    function updateAllPlacedPlayerCoords() {
        const placedPlayers = grid.querySelectorAll('.placed-player');
        placedPlayers.forEach(player => {
            const row = parseInt(player.dataset.row);
            const col = parseInt(player.dataset.col);
            const coords = getPlacedPlayerCoords(row, col);
            const coordsDiv = player.querySelector('.player-coords');
            if (coordsDiv) {
                coordsDiv.textContent = `(${coords.x}, ${coords.y})`;
            }
        });
    }

    

    // Handle click on center coordinate cell
    function handleCenterClick(e) {
        e.stopPropagation();
        
        const xInput = prompt('Enter X coordinate for center 3x3 zone:', baseCoordinate.x);
        if (xInput === null) return; // User cancelled
        
        const yInput = prompt('Enter Y coordinate for center 3x3 zone:', baseCoordinate.y);
        if (yInput === null) return; // User cancelled
        
        const x = parseInt(xInput);
        const y = parseInt(yInput);
        
        if (isNaN(x) || isNaN(y)) {
            alert('Please enter valid numbers');
            return;
        }
        
        // Update base coordinate and recalculate all cells and placed players
        baseCoordinate.x = x;
        baseCoordinate.y = y;
        updateGridCoordinates();
        updateAllPlacedPlayerCoords();
    }

    // Get grid dimensions based on screen size
    function getGridDimensions() {
        const width = window.innerWidth;
        if (width <= 645) {
            return { cellSize: 25, gap: 1, padding: '0.5rem', playerSize: 51, obstructionSize: 25 };
        } else if (width <= 768) {
            return { cellSize: 30, gap: 2, padding: '0.5rem', playerSize: 62, obstructionSize: 30 };
        } else {
            return { cellSize: 30, gap: 2, padding: '1rem', playerSize: 62, obstructionSize: 30 };
        }
    }

    // Helper function to set active element and remove active class from others
    function setActiveElement(element) {
        // Remove active class from all placed items
        document.querySelectorAll('.placed-player.active, .placed-obstruction.active').forEach(el => {
            el.classList.remove('active');
        });

        // Add active class to the new element
        if (element) {
            element.classList.add('active');
        }

        lastPlacedElement = element;
    }

    // Create 15x15 grid
    for (let row = 0; row < 15; row++) {
        for (let col = 0; col < 15; col++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell';
            cell.dataset.row = row;
            cell.dataset.col = col;

            // Calculate world coordinates: baseCoord + (centerCellPos - cellPos)
            // Center cell is at (8, 8)
            // X and Y axes are flipped: X uses row, Y uses col
            const worldX = baseCoordinate.x + (8 - row);
            const worldY = baseCoordinate.y + (8 - col);
            cell.dataset.coords = `${worldX},${worldY}`;

            // Mark center 3x3 zone (rows 6-8, cols 6-8)
            if (row >= 6 && row <= 8 && col >= 6 && col <= 8) {
                cell.classList.add('center-zone');
                
                // Make only the bottom-right cell (8,8) of the center zone clickable
                if (row === 8 && col === 8) {
                    cell.classList.add('clickable-center');
                    cell.addEventListener('click', handleCenterClick);
                }
            }

            // Add directional buttons on specific center zone cells (2, 4, 6, 8)
            // Tile 2: row 6, col 7 (UP - moves items UP/North on grid)
            // Tile 4: row 7, col 6 (LEFT - moves items LEFT/West on grid)
            // Tile 6: row 7, col 8 (RIGHT - moves items RIGHT/East on grid)
            // Tile 8: row 8, col 7 (DOWN - moves items DOWN/South on grid)
            if ((row === 6 && col === 7) || (row === 7 && col === 6) ||
                (row === 7 && col === 8) || (row === 8 && col === 7)) {
                cell.classList.add('direction-btn');

                // Set direction and arrow (arrows point in the direction items will move)
                if (row === 6 && col === 7) {
                    // UP button - moves items up (north/top)
                    cell.dataset.direction = 'up';
                    cell.dataset.arrow = 'â–²'; // Arrow points up
                } else if (row === 7 && col === 6) {
                    // LEFT button - moves items left (west/left)
                    cell.dataset.direction = 'left';
                    cell.dataset.arrow = 'â—€'; // Arrow points left
                } else if (row === 7 && col === 8) {
                    // RIGHT button - moves items right (east/right)
                    cell.dataset.direction = 'right';
                    cell.dataset.arrow = 'â–¶'; // Arrow points right
                } else if (row === 8 && col === 7) {
                    // DOWN button - moves items down (south/bottom)
                    cell.dataset.direction = 'down';
                    cell.dataset.arrow = 'â–¼'; // Arrow points down
                }

                // Add click listener for direction control
                cell.addEventListener('click', handleDirectionClick);
            }

            // Add drop zone listeners (but not on direction buttons)
            if (!cell.classList.contains('direction-btn')) {
                cell.addEventListener('dragover', handleDragOver);
                cell.addEventListener('drop', handleDrop);
            }

            grid.appendChild(cell);
        }
    }

    // Sort users based on selected sort option
    function sortUsers(users, sortType) {
        const usersCopy = [...users];
        switch(sortType) {
            case 'tc_desc':
                return usersCopy.sort((a, b) => b.furnace_lv - a.furnace_lv);
            case 'tc_asc':
                return usersCopy.sort((a, b) => a.furnace_lv - b.furnace_lv);
            case 'alpha_asc':
                return usersCopy.sort((a, b) => a.nickname.localeCompare(b.nickname));
            case 'alpha_desc':
                return usersCopy.sort((a, b) => b.nickname.localeCompare(a.nickname));
            default:
                return usersCopy;
        }
    }

    // Render player cards
    function renderPlayerCards() {
        playerCardsContainer.innerHTML = '';

        if (currentAllianceId && usersByAlliance[currentAllianceId]) {
            const sortedUsers = sortUsers(usersByAlliance[currentAllianceId], currentSortType);

            sortedUsers.forEach(user => {
                const card = document.createElement('div');
                card.className = 'player-card';
                card.dataset.type = 'player';
                card.dataset.nickname = user.nickname;
                card.dataset.furnaceLv = user.furnace_lv;
                card.dataset.avatarUrl = user.avatar_url || '';
                // Set avatar as background using CSS custom property
                if (user.avatar_url) {
                    card.style.setProperty('--avatar-url', `url('${user.avatar_url}')`);
                }

                // Check if this player has already been placed
                const playerKey = `${currentAllianceId}_${user.nickname}`;
                if (usedPlayers.has(playerKey)) {
                    card.classList.add('used');
                    card.draggable = false;
                } else {
                    card.draggable = true;
                    card.addEventListener('dragstart', handleDragStart);
                    card.addEventListener('dragend', handleDragEnd);
                }

                // Display TC level and nickname (TC first, then name)
                const tcDiv = document.createElement('div');
                tcDiv.textContent = `TC${user.furnace_lv}`;
                tcDiv.style.fontSize = '0.6rem';
                tcDiv.style.opacity = '0.8';
                tcDiv.style.marginBottom = '-1px';

                const nameDiv = document.createElement('div');
                nameDiv.textContent = user.nickname;
                nameDiv.style.fontSize = '0.65rem';
                nameDiv.style.marginTop = '0px';

                // Create a text wrapper to keep text vertically aligned
                const textWrapper = document.createElement('div');
                textWrapper.className = 'player-card-text-wrapper';
                textWrapper.appendChild(tcDiv);
                textWrapper.appendChild(nameDiv);
                card.appendChild(textWrapper);

                playerCardsContainer.appendChild(card);
            });
        }
    }

    // Alliance dropdown change
    allianceDropdown.addEventListener('change', (e) => {
        currentAllianceId = e.target.value;
        renderPlayerCards();
    });

    // Sort link click handlers
    sortTcLink.addEventListener('click', (e) => {
        e.preventDefault();
        // Toggle between descending and ascending
        tcSortAscending = !tcSortAscending;
        currentSortType = tcSortAscending ? 'tc_asc' : 'tc_desc';

        // Update link text
        sortTcLink.textContent = tcSortAscending ? 'TC â†‘' : 'TC â†“';

        // Update active state
        sortTcLink.classList.add('active');
        sortAlphaLink.classList.remove('active');

        renderPlayerCards();
    });

    sortAlphaLink.addEventListener('click', (e) => {
        e.preventDefault();
        // Toggle between A-Z and Z-A
        alphaSortAscending = !alphaSortAscending;
        currentSortType = alphaSortAscending ? 'alpha_asc' : 'alpha_desc';

        // Update link text
        sortAlphaLink.textContent = alphaSortAscending ? 'A-Z' : 'Z-A';

        // Update active state
        sortAlphaLink.classList.add('active');
        sortTcLink.classList.remove('active');

        renderPlayerCards();
    });

    // Drag and drop handlers
    function handleDragStart(e) {
        draggedElement = e.target;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', e.target.innerHTML);

        // The dragging class makes it semi-transparent
        // but the card itself will maintain its diamond shape
        e.target.classList.add('dragging');
    }

    function handleDragEnd(e) {
        e.target.classList.remove('dragging');
    }

    function handleDragOver(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    // Helper function to check if a cell is occupied
    function isCellOccupied(row, col, excludeElement = null) {
        const placedElements = grid.querySelectorAll('.placed-player, .placed-obstruction');
        for (let element of placedElements) {
            if (element === excludeElement) continue;

            const elementRow = parseInt(element.dataset.row);
            const elementCol = parseInt(element.dataset.col);
            const elementType = element.dataset.type;

            if (elementType === 'player') {
                // Player occupies 2x2 cells
                if (row >= elementRow && row <= elementRow + 1 &&
                    col >= elementCol && col <= elementCol + 1) {
                    return true;
                }
            } else if (elementType === 'obstruction') {
                // Obstruction occupies 1x1 cell
                if (row === elementRow && col === elementCol) {
                    return true;
                }
            }
        }
        return false;
    }

    // Helper function to check if center zone overlaps
    function isInCenterZone(row, col, width, height) {
        for (let r = row; r < row + height; r++) {
            for (let c = col; c < col + width; c++) {
                if (r >= 6 && r <= 8 && c >= 6 && c <= 8) {
                    return true;
                }
            }
        }
        return false;
    }

    function handleDrop(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }

        if (!draggedElement) return false;

        const cell = e.target.closest('.grid-cell');
        if (!cell) return false;

        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const type = draggedElement.dataset.type;

        // Check if this is a repositioning of an existing placed element
        const isRepositioning = draggedElement.classList.contains('placed-player') ||
                                draggedElement.classList.contains('placed-obstruction');

        if (type === 'player') {
            // Check if 2x2 space is available
            if (row + 1 >= 15 || col + 1 >= 15) {
                alert('Not enough space for player card (needs 2x2)');
                return false;
            }

            // Check for center zone collision
            if (isInCenterZone(row, col, 2, 2)) {
                alert('Cannot place player on center zone (3x3)');
                return false;
            }

            // Check for collisions with other placed items
            for (let r = row; r <= row + 1; r++) {
                for (let c = col; c <= col + 1; c++) {
                    if (isCellOccupied(r, c, isRepositioning ? draggedElement : null)) {
                        alert('Space is occupied by another item');
                        return false;
                    }
                }
            }

            if (isRepositioning) {
                // Update position of existing element
                const dims = getGridDimensions();
                draggedElement.dataset.row = row;
                draggedElement.dataset.col = col;
                draggedElement.style.left = `calc(${dims.padding} + ${col} * (${dims.cellSize}px + ${dims.gap}px))`;
                draggedElement.style.top = `calc(${dims.padding} + ${row} * (${dims.cellSize}px + ${dims.gap}px))`;
                // Update coordinates
                const coords = getPlacedPlayerCoords(row, col);
                const coordsDiv = draggedElement.querySelector('.player-coords');
                if (coordsDiv) {
                    coordsDiv.textContent = `(${coords.x}, ${coords.y})`;
                }
                setActiveElement(draggedElement);
            } else {
                // Create new placed player element
                const placed = document.createElement('div');
                placed.className = 'placed-player';
                placed.dataset.type = 'player';
                placed.dataset.row = row;
                placed.dataset.col = col;
                placed.dataset.nickname = draggedElement.dataset.nickname;
                placed.dataset.furnaceLv = draggedElement.dataset.furnaceLv;
                placed.dataset.avatarUrl = draggedElement.dataset.avatarUrl;
                placed.draggable = true;
                // Set avatar as background using CSS custom property
                if (draggedElement.dataset.avatarUrl) {
                    placed.style.setProperty('--avatar-url', `url('${draggedElement.dataset.avatarUrl}')`);
                }

                // Display TC level, nickname, and coordinates (TC first, then name, then coords)
                const tcDiv = document.createElement('div');
                tcDiv.textContent = `TC${draggedElement.dataset.furnaceLv}`;
                tcDiv.style.fontSize = '0.6rem';
                tcDiv.style.opacity = '0.8';
                tcDiv.style.marginBottom = '-1px';

                const nameDiv = document.createElement('div');
                nameDiv.textContent = draggedElement.dataset.nickname;
                nameDiv.style.fontSize = '0.65rem';
                nameDiv.style.marginTop = '0px';
                nameDiv.style.marginBottom = '-1px';

                const coordsDiv = document.createElement('div');
                coordsDiv.className = 'player-coords';
                coordsDiv.style.fontSize = '0.5rem';
                coordsDiv.style.marginTop = '0px';
                coordsDiv.style.opacity = '0.7';
                const coords = getPlacedPlayerCoords(row, col);
                coordsDiv.textContent = `(${coords.x}, ${coords.y})`;

                // Create a text wrapper to keep text vertically aligned
                const textWrapper = document.createElement('div');
                textWrapper.className = 'placed-player-text-wrapper';
                textWrapper.appendChild(tcDiv);
                textWrapper.appendChild(nameDiv);
                textWrapper.appendChild(coordsDiv);
                placed.appendChild(textWrapper);

                // Position: 2x2 cells
                const dims = getGridDimensions();
                placed.style.width = `${dims.playerSize}px`;
                placed.style.height = `${dims.playerSize}px`;
                placed.style.left = `calc(${dims.padding} + ${col} * (${dims.cellSize}px + ${dims.gap}px))`;
                placed.style.top = `calc(${dims.padding} + ${row} * (${dims.cellSize}px + ${dims.gap}px))`;

                placed.addEventListener('dragstart', handlePlacedDragStart);
                placed.addEventListener('click', () => {
                    // Mark this card as active when clicked
                    setActiveElement(placed);
                    showDirectionControl();
                });
                placed.addEventListener('dblclick', () => {
                    // Mark player as available again when removed
                    const playerKey = `${currentAllianceId}_${placed.dataset.nickname}`;
                    usedPlayers.delete(playerKey);
                    placed.remove();
                    if (lastPlacedElement === placed) {
                        setActiveElement(null);
                    }
                    showDirectionControl();
                    renderPlayerCards(); // Re-render to show card as available
                });

                // Mark this player as used
                const playerKey = `${currentAllianceId}_${draggedElement.dataset.nickname}`;
                usedPlayers.add(playerKey);
                renderPlayerCards(); // Re-render to show card as used

                grid.appendChild(placed);
                setActiveElement(placed);
                showDirectionControl();
            }

        } else if (type === 'obstruction') {
            // Check for center zone collision
            if (isInCenterZone(row, col, 1, 1)) {
                alert('Cannot place obstruction on center zone (3x3)');
                return false;
            }

            // Check if cell is occupied
            if (isCellOccupied(row, col, isRepositioning ? draggedElement : null)) {
                alert('Cell is occupied by another item');
                return false;
            }

            if (isRepositioning) {
                // Update position of existing element
                const dims = getGridDimensions();
                draggedElement.dataset.row = row;
                draggedElement.dataset.col = col;
                draggedElement.style.left = `calc(${dims.padding} + ${col} * (${dims.cellSize}px + ${dims.gap}px))`;
                draggedElement.style.top = `calc(${dims.padding} + ${row} * (${dims.cellSize}px + ${dims.gap}px))`;
                // Update coordinates
                const coords = getPlacedPlayerCoords(row, col);
                const coordsDiv = draggedElement.querySelector('.player-coords');
                if (coordsDiv) {
                    coordsDiv.textContent = `(${coords.x}, ${coords.y})`;
                }
                setActiveElement(draggedElement);
            } else {
                // Create new placed obstruction element
                const placed = document.createElement('div');
                placed.className = 'placed-obstruction';
                placed.dataset.emoji = 'ðŸš§';
                placed.dataset.type = 'obstruction';
                placed.dataset.row = row;
                placed.dataset.col = col;
                placed.draggable = true;

                // Position: 1x1 cell
                const dims = getGridDimensions();
                placed.style.width = `${dims.obstructionSize}px`;
                placed.style.height = `${dims.obstructionSize}px`;
                placed.style.left = `calc(${dims.padding} + ${col} * (${dims.cellSize}px + ${dims.gap}px))`;
                placed.style.top = `calc(${dims.padding} + ${row} * (${dims.cellSize}px + ${dims.gap}px))`;

                placed.addEventListener('dragstart', handlePlacedDragStart);
                placed.addEventListener('click', () => {
                    // Mark this obstruction as active when clicked
                    setActiveElement(placed);
                    showDirectionControl();
                });
                placed.addEventListener('dblclick', () => {
                    placed.remove();
                    if (lastPlacedElement === placed) {
                        setActiveElement(null);
                    }
                    showDirectionControl();
                });

                grid.appendChild(placed);
                setActiveElement(placed);
                showDirectionControl();
            }
        }

        return false;
    }

    // Show/hide direction control based on whether there's a last placed element
    function showDirectionControl() {
        // Update visual feedback for direction buttons
        const directionButtons = document.querySelectorAll('.direction-btn');
        directionButtons.forEach(btn => {
            if (lastPlacedElement) {
                btn.style.opacity = '1';
            } else {
                btn.style.opacity = '0.5';
            }
        });
    }

    // Direction control button click handler
    function handleDirectionClick(e) {
        const direction = e.currentTarget.dataset.direction;
        if (!direction || !lastPlacedElement) return;

        const currentRow = parseInt(lastPlacedElement.dataset.row);
        const currentCol = parseInt(lastPlacedElement.dataset.col);
        const type = lastPlacedElement.dataset.type;
        let newRow = currentRow;
        let newCol = currentCol;

        // Determine new position based on direction
        switch(direction) {
            case 'up':
                newRow = currentRow - 1;
                break;
            case 'down':
                newRow = currentRow + 1;
                break;
            case 'left':
                newCol = currentCol - 1;
                break;
            case 'right':
                newCol = currentCol + 1;
                break;
        }

        // Validate and move (reuse existing validation logic)
        if (type === 'player') {
            if (newRow < 0 || newRow + 1 >= 15 || newCol < 0 || newCol + 1 >= 15) {
                return; // Out of bounds
            }

            if (isInCenterZone(newRow, newCol, 2, 2)) {
                return; // Cannot move into center zone
            }

            for (let r = newRow; r <= newRow + 1; r++) {
                for (let c = newCol; c <= newCol + 1; c++) {
                    if (isCellOccupied(r, c, lastPlacedElement)) {
                        return; // Space is occupied
                    }
                }
            }
        } else if (type === 'obstruction') {
            if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) {
                return; // Out of bounds
            }

            if (isInCenterZone(newRow, newCol, 1, 1)) {
                return; // Cannot move into center zone
            }

            if (isCellOccupied(newRow, newCol, lastPlacedElement)) {
                return; // Cell is occupied
            }
        }

        // Update position
        const dims = getGridDimensions();
        lastPlacedElement.dataset.row = newRow;
        lastPlacedElement.dataset.col = newCol;
        lastPlacedElement.style.left = `calc(${dims.padding} + ${newCol} * (${dims.cellSize}px + ${dims.gap}px))`;
        lastPlacedElement.style.top = `calc(${dims.padding} + ${newRow} * (${dims.cellSize}px + ${dims.gap}px))`;

        // Update coordinates if this is a player
        if (type === 'player') {
            const coords = getPlacedPlayerCoords(newRow, newCol);
            const coordsDiv = lastPlacedElement.querySelector('.player-coords');
            if (coordsDiv) {
                coordsDiv.textContent = `(${coords.x}, ${coords.y})`;
            }
        }
    }

    function handlePlacedDragStart(e) {
        draggedElement = e.target;
        e.dataTransfer.effectAllowed = 'move';
    }

    // Setup obstruction card drag
    document.querySelector('.obstruction-card').addEventListener('dragstart', handleDragStart);
    document.querySelector('.obstruction-card').addEventListener('dragend', handleDragEnd);

    // Helper function to flash directional button
    function flashDirectionButton(direction) {
        const button = document.querySelector(`.direction-btn[data-direction="${direction}"]`);
        if (button) {
            button.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
            setTimeout(() => {
                button.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
            }, 150);
        }
    }

    // Keyboard controls for nudging last placed card
    document.addEventListener('keydown', (e) => {
        if (!lastPlacedElement) return;

        const currentRow = parseInt(lastPlacedElement.dataset.row);
        const currentCol = parseInt(lastPlacedElement.dataset.col);
        const type = lastPlacedElement.dataset.type;
        let newRow = currentRow;
        let newCol = currentCol;
        let direction = null;

        // Determine new position based on arrow key
        switch(e.key) {
            case 'ArrowUp':
                newRow = currentRow - 1;
                direction = 'up';
                e.preventDefault();
                break;
            case 'ArrowDown':
                newRow = currentRow + 1;
                direction = 'down';
                e.preventDefault();
                break;
            case 'ArrowLeft':
                newCol = currentCol - 1;
                direction = 'left';
                e.preventDefault();
                break;
            case 'ArrowRight':
                newCol = currentCol + 1;
                direction = 'right';
                e.preventDefault();
                break;
            default:
                return;
        }

        // Validate new position is within grid bounds
        if (type === 'player') {
            if (newRow < 0 || newRow + 1 >= 15 || newCol < 0 || newCol + 1 >= 15) {
                return; // Out of bounds
            }

            // Check for center zone collision
            if (isInCenterZone(newRow, newCol, 2, 2)) {
                return; // Cannot move into center zone
            }

            // Check for collisions with other placed items
            for (let r = newRow; r <= newRow + 1; r++) {
                for (let c = newCol; c <= newCol + 1; c++) {
                    if (isCellOccupied(r, c, lastPlacedElement)) {
                        return; // Space is occupied
                    }
                }
            }
        } else if (type === 'obstruction') {
            if (newRow < 0 || newRow >= 15 || newCol < 0 || newCol >= 15) {
                return; // Out of bounds
            }

            // Check for center zone collision
            if (isInCenterZone(newRow, newCol, 1, 1)) {
                return; // Cannot move into center zone
            }

            // Check if cell is occupied
            if (isCellOccupied(newRow, newCol, lastPlacedElement)) {
                return; // Cell is occupied
            }
        }

        // Update position
        const dims = getGridDimensions();
        lastPlacedElement.dataset.row = newRow;
        lastPlacedElement.dataset.col = newCol;
        lastPlacedElement.style.left = `calc(${dims.padding} + ${newCol} * (${dims.cellSize}px + ${dims.gap}px))`;
        lastPlacedElement.style.top = `calc(${dims.padding} + ${newRow} * (${dims.cellSize}px + ${dims.gap}px))`;

        // Update coordinates if this is a player
        if (type === 'player') {
            const coords = getPlacedPlayerCoords(newRow, newCol);
            const coordsDiv = lastPlacedElement.querySelector('.player-coords');
            if (coordsDiv) {
                coordsDiv.textContent = `(${coords.x}, ${coords.y})`;
            }
        }

        // Flash the corresponding direction button
        if (direction) {
            flashDirectionButton(direction);
        }
    });
</script>
{% endblock %}
